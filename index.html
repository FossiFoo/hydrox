

<!DOCTYPE html>
<html >
  <head>
    <meta charset="UTF-8">
    <meta name="google" value="notranslate">
    <link rel="icon" type="image/png" href="img/favicon.png" />

    <title>hydrox</title>

    
  <link href='http://fonts.googleapis.com/css?family=Raleway:300' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/css/bootstrap.min.css">
  <link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.3.0/css/font-awesome.min.css">

  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/highlight.min.js"></script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/languages/clojure.min.js"></script>
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/magula.min.css">

  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/js/bootstrap.min.js"></script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.2/angular.min.js"></script>
  <script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/angularjs/1.4.2/angular-cookies.min.js"></script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/angular-ui-bootstrap/0.13.0/ui-bootstrap-tpls.min.js"></script>
  <script type="text/javascript" src="js/angular-highlightjs.min.js"></script>

  <link rel="stylesheet" type="text/css" href="css/rdash.min.css">
  <link rel="stylesheet" type="text/css" href="css/scrollspy.css">


  <script>
    window.console = window.console || function(t) {};
    window.open = function(){ console.log("window.open is disabled."); };
    window.print   = function(){ console.log("window.print is disabled."); };
  </script>

  <script>
    var app = angular.module('app', ['hljs']);
  </script>
  </head>

  <body ng-app="app" data-spy="scroll" data-target=".scrollspy">
  <!-- Fixed navbar -->
    <nav class="navbar navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="index.html"><img src="img/logo-white.png"></a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li>
              <a href="https://github.com/helpshift/hydrox" target="_blank">Github</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>


  <div class="container row">
    <div class="col-md-4 scrollspy pull-right">
      <ul id="nav" class="nav hidden-xs hidden-sm" data-spy="affix">
        <li><a href="#introduction">1  &nbsp;&nbsp; Introduction</a><ul class="nav"><li><a href="#overview">1.1  &nbsp;&nbsp; Overview</a></li><li><a href="#installation">1.2  &nbsp;&nbsp; Installation</a></li><li><a href="#motivation">1.3  &nbsp;&nbsp; Motivation</a></li><li><a href="#literate-programming">1.4  &nbsp;&nbsp; Literate Programming</a></li></ul></li><li><a href="#facillitating-communication">2  &nbsp;&nbsp; Facillitating Communication</a><ul class="nav"><li><a href="#code-as-communication">2.1  &nbsp;&nbsp; Code as Communication</a></li><li><a href="#functional-level-documentation">2.2  &nbsp;&nbsp; Functional Level Documentation</a></li><li><a href="#design-level-documentation">2.3  &nbsp;&nbsp; Design Level Documentation</a></li></ul></li><li><a href="#api-reference">3  &nbsp;&nbsp; API Reference</a><ul class="nav"><li><a href="#the-basics">3.1  &nbsp;&nbsp; The Basics</a></li><li><a href="#sectioning-elements">3.2  &nbsp;&nbsp; Sectioning Elements</a></li><li><a href="#content-elements">3.3  &nbsp;&nbsp; Content Elements</a></li><li><a href="#code-elements">3.4  &nbsp;&nbsp; Code Elements</a></li></ul></li><li><a href="#a-bugs-life">4  &nbsp;&nbsp; A Bug's Life</a><ul class="nav"><li><a href="#version-one">4.1  &nbsp;&nbsp; Version One</a></li><li><a href="#version-two">4.2  &nbsp;&nbsp; Version Two</a></li><li><a href="#the-bug-surfaces">4.3  &nbsp;&nbsp; The Bug Surfaces</a></li></ul></li>
      </ul>
    </div>
    <div class="col-md-8" id="content">
      <div class="jumbotron">
        <div class="container">
          <h1>hydrox</h1>
          <h4>dive deeper into your code</h4>
        </div>
      </div>
      <section class="chapter" id="introduction"><h2 class="chapter">1  &nbsp;&nbsp; Introduction</h2><section class="section" id="overview"><h3 class="section">1.1  &nbsp;&nbsp; Overview</h3><div class="paragraph"><p><a href='https://www.github.com/helpshift/hydrox'>hydrox</a> assists in the transmission of knowledge around a clojure project, providing in-repl management of documentation, docstrings and metadata through the reuse/repurposing of test code. Facillitating the creation of 'documentation that we can run', the tool allows for a design-orientated workflow for the programming process, blurring the boundaries between design, development, testing and documentation.</p></div><div class="figure"><a name="overview-0"></a><div class="img"><img src="https://raw.githubusercontent.com/helpshift/hydrox/master/template/assets/img/hydrox-overview.png" width="100%" /></div><h4><i>fig.1  &nbsp;-&nbsp; Overview</i></h4></div></section><section class="section" id="installation"><h3 class="section">1.2  &nbsp;&nbsp; Installation</h3><section class="subsection" id="standard"><h4 class="subsection">1.2.1  &nbsp;&nbsp; Standard</h4><div class="paragraph"><p>In your project.clj, add hydrox to the <code>&#91;:profiles :dev :dependencies&#93;</code> entry:</p><pre><code class="clojure">&#40;defproject ...
    ...
    :profiles {:dev {:dependencies &#91;...
                                    &#91;helpshift/hydrox &quot;0.1.7&quot;&#93;
                                    ...&#93;}}
    ...&#41;
</code></pre></div><div class="paragraph"><p>All functionality is the <code>hydrox.core</code> namespace:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(use 'hydrox.core)


(dive)    ;; initialises the tool, and watches project for files changes

(import-docstring) ;; imports docstrings into functions from test files

(purge-docstring)  ;; purges docstrings from functions

(generate-docs)    ;; generates html (like this one) from test files

(surface) ;; stops the tool</div></div></section><section class="subsection" id="vinyasa"><h4 class="subsection">1.2.2  &nbsp;&nbsp; Vinyasa</h4><div class="paragraph"><p>A better experience can be obtained by using <a href='https://github.com/zcaudate/vinyasa'>vinyasa</a> and editing your <code>&#126;/.lein/profiles.clj</code> to inject all <code>hydrox</code> vars into the <code>.</code> namespace:</p><pre><code class="clojure">{:user
   {:plugins &#91;...&#93;
    :dependencies &#91;&#91;im.chit/vinyasa.inject &quot;0.3.4&quot;&#93;
                   &#91;helpshift/hydrox &quot;0.1.7&quot;&#93;&#93;
    :injections
    &#91;&#40;require '&#91;vinyasa.inject :as inject&#93;&#41;
     &#40;inject/in &#91;hydrox.core dive surface generate-docs
                             import-docstring purge-docstring&#93;&#41;&#93;}}
</code></pre></div><div class="paragraph"><p>Functions can then be used like this within the repl:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(./dive)


(./import-docstring)

(./purge-docstring)

(./generate-docs)

(./surface)</div></div></section></section><section class="section" id="motivation"><h3 class="section">1.3  &nbsp;&nbsp; Motivation</h3><div class="paragraph"><p>Programming is a very precise art form. Programming mistakes, especially the little ones, can result in dire consequences and much wasted time. We therefore use tools such as debuggers, type checkers and test frameworks to make our coding lives easier and our source code correct.</p><p>Documentation is the programmers' means of communicating how to use or build upon a library, usually to a larger audience of peers. This means that any mistakes in the documentation results in wasted time for <em>all involved</em>. Therefore any mistake in documentation can have a <em>greater effect</em> than a mistake in source code because it wastes <em>everybody's</em> time.</p><p>There are various tools for documentation like <code>latex</code>, <code>wiki</code> and <code>markdown</code>. However, none address the issue that code examples in the documentation are not checked for correctness. <code>hydrox</code> attempts to bridge the gap between writing tests and writing documentation by introducing the following features:</p></div><section class="subsection" id="features"><h4 class="subsection">1.3.1  &nbsp;&nbsp; Features</h4><div class="paragraph"><p>The features are:</p><ol><li>To generate <code>.html</code> documentation from a <code>.clj</code> test file.</li><li>Management of function docstrings and metadata through tests</li><li>Express documentation elements as clojure datastructures.</li><li>Render code, clojure.test and midje test cases as examples.</li><li>Latex-like numbering and linking facilities.</li></ol></div></section><section class="subsection" id="benefits"><h4 class="subsection">1.3.2  &nbsp;&nbsp; Benefits</h4><div class="paragraph"><p>In this way, the project benefits in multiple ways:</p><ol><li>All documentation errors can be eliminated.</li><li>Removes the need to cut and copy test examples into a readme file.</li></ol></div></section><section class="subsection" id="improvements"><h4 class="subsection">1.3.3  &nbsp;&nbsp; Improvements</h4><div class="paragraph"><p>The precessor of <a href='https://github.com/helpshift/hydrox'>hydrox</a> was <a href='https://github.com/zcaudate/lein-midje-doc'>midje-doc</a>, and it provided very much the same functionalities as the current <code>hydrox</code> implementation. Whilst <a href='https://github.com/zcaudate/lein-midje-doc'>midje-doc</a> was built primarily as a leiningen plugin, it was found that the tool was more effective for the development when used within the repl.</p><p>There are significant improvements of <a href='https://github.com/helpshift/hydrox'>hydrox</a> over <a href='https://github.com/zcaudate/lein-midje-doc'>midje-doc</a> including:</p><ul><li>Declarative source code traversal using <a href='https://www.github.com/zcaudate/jai'>jai</a></li><li>Extensible micropass pipeline for compilation and linking</li><li>Customisable templates system for html documentataion</li><li>Code-diffing mechanism for efficient management of filesystem changes</li></ul></div></section></section><section class="section" id="literate-programming"><h3 class="section">1.4  &nbsp;&nbsp; Literate Programming</h3><div class="paragraph"><p>The phrase 'Literate Programming' has been bandied around alot lately. The main idea is that the code is written in a way that allows both a machine <em>and</em> a person to understand what is going on. Most seem to agree that it is a great idea. The reuse factor of not writing seperate documentation alone brings great excitement to many developers. However, we must understand that methods of effective communication to humans and machines are very different:</p><p><strong>Communication to Machines</strong> are usually linear and based on a specific set of instructions. First Do This, Then Do That.... Machines don't really care what the code does. It just executes whatever code it has been given. The main importance of establishing that a program is correct is to give it a set of verifible <code>input</code>/<code>output</code> responses and see if it behaves a certain way.</p><p><strong>Communication to Humans</strong> are usually less procedural and more relational. We wish to be engaged, inspired and taught, not given a sequence of instructions that each break down to even smaller sequences. The best documentation are usally seperated into logical sections like an <code>overview</code>, <code>table of contents</code>, <code>list of figures</code>, <code>chapters</code>, <code>sections</code> and <code>subsections</code>. There are <code>text</code>, <code>code</code>, <code>pictures</code>, even <code>sound</code> and <code>video</code>. Documentation structure resemble trees, with links between content that connect related topics and content. They do not resemble program code and therefore should be created independently of the machine code itself.</p></div></section></section><section class="chapter" id="facillitating-communication"><h2 class="chapter">2  &nbsp;&nbsp; Facillitating Communication</h2><section class="section" id="code-as-communication"><h3 class="section">2.1  &nbsp;&nbsp; Code as Communication</h3><div class="paragraph"><p>The primary reason for building <code>hydrox</code> was to simplify the communication process across a clojure project. In general, the programming process can be seen as a set of different communication types with the developer acting as the facillitator for the following:</p><ol><li>with the machine telling it what to do (code)</li><li>with the machine, verifying that it has done it's job (unit and integration tests)</li><li>with themselves/other developers, telling them how to use the function (unit tests and docstrings)</li><li>with the end user, telling them how to do it (design/integration documentation)</li></ol><p>Notice that with the 4 points listed, there happens to be some overlap between 2 and 3 (unit tests) as well as 2 and 4 (integration). We can categorise the overlap as follows:</p><ol><li>unit/function level documentation (intended for communicating with a machine/developer)</li><li>design/integration level documentation (intended for communicating with a consumer)</li></ol><p>This overlap is very important because this is the one area where repetitive activities occur. <a href='https://www.github.com/helpshift/hydrox'>hydrox</a> helps limit this repetition through automation of the documentation workflow.</p></div></section><section class="section" id="functional-level-documentation"><h3 class="section">2.2  &nbsp;&nbsp; Functional Level Documentation</h3><div class="paragraph"><p>The best description for our functions are not found in <em>source files</em> but in the <em>test files</em>. Tests <strong>are</strong> potentially the best documentation because they provide information about what a function outputs, what inputs it accepts and what exceptions it throws. The best place to display functional level documentation is in the docstring as the clojure ecosystem has amazing support for the uses of docstings in tools such as cider, cursive, codox, grimoire and many others.</p></div><div class="paragraph"><p>Lets discuss the problem with the following piece of code:</p></div><div class="code"><a name="split-string-normal"></a><h5>e.2.1  &nbsp;-&nbsp; split-string source</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(defn split-string
  &quot;The split-string function is used to split a string
  in two according to the idx that is passed.&quot;
  [s idx]
  [(.substring s 0 idx) (.substring s idx)])</div></div><div class="paragraph"><p>Technically, everything is fine except that the docstring is pretty much useless. Instead of writing vague phrases, we write our test as follows (usually in another file):</p></div><div class="code"><a name="split-string-tests"></a><h5>e.2.2  &nbsp;-&nbsp; split-string tests</h5><div hljs="hljs" language="clojure" no-escape="no-escape">^{:refer documentation.hydrox-guide/split-string :added &quot;0.1&quot;}
(facts &quot;split-string usage:&quot;

(split-string &quot;abcde&quot; 1)
=&gt; [&quot;a&quot; &quot;bcde&quot;]

(split-string &quot;abcde&quot; 3)
=&gt; [&quot;abc&quot; &quot;de&quot;])</div></div><div class="paragraph"><p>It can be seen that test cases provides a much better explaination for <code>split-string</code> than the source docstring because any developer can immediately tell what inputs the function accepts and what outputs it returns. In this case, <a href='https://github.com/helpshift/hydrox'>hydrox</a> provides the function <code>import-docstring</code> to turn a test into a docstring and then deliver it back into the source code.</p></div><section class="subsection" id="import-docstring"><h4 class="subsection">2.2.1  &nbsp;&nbsp; Import Docstring</h4><div class="paragraph"><p>The following hydrox calls:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(hydrox.core/dive)
(hydrox.core/import-docstring)</div></div><div class="paragraph"><p>Results in the <code>split-string</code> function looking like this:</p></div><div class="code"><a name="split-string-import"></a><h5>e.2.3  &nbsp;-&nbsp; split-string after import-docstring</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(defn split-string
  &quot;split-string usage:

   (split-string &#92;&quot;abcde&#92;&quot; 1)
   =&gt; [&#92;&quot;a&#92;&quot; &#92;&quot;bcde&#92;&quot;]

   (split-string &#92;&quot;abcde&#92;&quot; 3)
   =&gt; [&#92;&quot;abc&#92;&quot; &#92;&quot;de&#92;&quot;]&quot;
  {:added &quot;0.1&quot;}
  [s idx]
  [(.substring s 0 idx) (.substring s idx)])</div></div><div class="paragraph"><p>It is possible to target the docstring of a source file when the test code is in another file is due to the <code>&#94;{:refer documentation.hydrox-guide/split-string :added &quot;0.1&quot;}</code> metadata that was included as part of the test. The other call to <code>dive</code> was needed to link the source and test files. It only needs to called once and will be explained in a later section.</p></div><div class="paragraph"></div></section><section class="subsection" id="purge-docstring"><h4 class="subsection">2.2.2  &nbsp;&nbsp; Purge Docstring</h4><div class="paragraph"><p>Sometimes, it's better to just concentrate on the function itself for more clarity, in this case, the <code>purge-docstring</code> function is really useful:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(hydrox.core/purge-docstring)</div></div><div class="paragraph"><p>Results in the <code>split-string</code> function looking like this, having no docstring or metadata:</p></div><div class="code"><a name="split-string-purge"></a><h5>e.2.4  &nbsp;-&nbsp; split-string after purge-docstring</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(defn split-string
  [s idx]
  [(.substring s 0 idx) (.substring s idx)])</div></div><div class="paragraph"><p>To bring the docstring and metadata back again, just make another call to <code>import-docstring</code>. With the tests for <code>split-string</code> in place, it is easy to manage metadata and docstrings. Having the information within the test files decreases source code clutter and we can import/purge them as needed, dependending upon the situation.</p></div></section></section><section class="section" id="design-level-documentation"><h3 class="section">2.3  &nbsp;&nbsp; Design Level Documentation</h3><div class="paragraph"><p>Documentation at the design level requires more visual elements than documentation at the function level. <a href='https://www.github.com/helpshift/hydrox'>hydrox</a> can generate html output based on a <code>.clj</code> file and a template. This requires some configuration and so the following is placed in the <code>project.clj</code> map.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(defproject ...
  ...
  :documentation
  {:site   &quot;sample&quot;
   :output &quot;docs&quot;
   :template {:path &quot;template&quot;
              :copy [&quot;assets&quot;]
              :defaults {:template     &quot;article.html&quot;
                         :navbar       [:file &quot;partials/navbar.html&quot;]
                         :dependencies [:file &quot;partials/deps-web.html&quot;]
                         :navigation   :navigation
                         :article      :article}}
   :paths [&quot;test/documentation&quot;]
   :files {&quot;sample-document&quot;
           {:input &quot;test/documentation/sample_document.clj&quot;
            :title &quot;a sample document&quot;
            :subtitle &quot;generating a document from code&quot;}}}
  ...)</div></div><div class="paragraph"><p>The <code>:documentation</code> key in <code>defproject</code> specifies which files to use as entry points to use for html generation. A sample can be seen below:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(ns documentation.sample.document
  (:require [midje.sweet :refer :all]))

[[:chapter {:tag &quot;hello&quot; :title &quot;Hello Midje Doc&quot;}]]

&quot;This is an introduction to writing with midje-doc.&quot;

[[:section {:title &quot;Defining a function&quot;}]]

&quot;We define function `add-5` below:&quot;

[[{:numbered false}]]
(defn add-5 [x]
  (+ x 5))

[[:section {:title &quot;Testing a function&quot;}]]

&quot;`add-5` outputs the following results:&quot;

(facts
  [[{:tag &quot;add-5-1&quot; :title &quot;1 add 5 = 6&quot;}]]
  (add-5 1) =&gt; 6

  [[{:tag &quot;add-5-10&quot; :title &quot;10 add 5 = 15&quot;}]]
  (add-5 10) =&gt; 15)</div></div><div class="paragraph"><p>A pretty looking html document can be generated by running <code>generate-docs</code>:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">(hydrox.core/generate-docs)</div></div><div class="paragraph"><p>The <code>:output</code> entry specifies the directory that files are rendered to, <code>:template</code>' specifies the files that are needed to generate the file. The current template will generate the same as the current documentation.</p></div></section></section><section class="chapter" id="api-reference"><h2 class="chapter">3  &nbsp;&nbsp; API Reference</h2><section class="section" id="the-basics"><h3 class="section">3.1  &nbsp;&nbsp; The Basics</h3><section class="subsection" id="elements"><h4 class="subsection">3.1.1  &nbsp;&nbsp; elements</h4><div class="paragraph"><p>Elements are constructed using a tag and a map contained within double square brackets. Elements tags have been inspired from latex:<ul><li><a href='#sectioning-elements'>Sectioning Elements</a></li><li><a href='#text-elements'>Text Elements</a></li><li><a href='#code-elements'>Code Elements</a></li><li><a href='#additional-elements'>Additional Elements</a></li></ul>Clojure strings are treated as paragraph elements whilst clojure forms are treated as code elements. <code>fact</code> and <code>comment</code> forms are also considered code elements. Elements will be described in detail in their respective sections.</p></div><div class="code"><a name="elements-ex1"></a><h5>e.3.1  &nbsp;-&nbsp; Element Notation</h5><div hljs="hljs" language="clojure" no-escape="no-escape">[[&lt;tag&gt; {&lt;key1&gt; &lt;value1&gt;, &lt;key2&gt; &lt;value2&gt;}]]

for example

[[:chapter {:title &quot;Hello World&quot; :tag &quot;hello&quot;}]]</div></div></section><section class="subsection" id="attributes"><h4 class="subsection">3.1.2  &nbsp;&nbsp; attributes</h4><div class="paragraph"><p>Attribute add additional metadata to elements. They are written as a single hashmap within double square brackets. Attributes mean nothing by themselves. They change the properties of elements directly after them.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">[[{:tag &quot;my-paragraph&quot;}]]
[[:paragraph {:content &quot;This is a paragraph&quot;}]]

is equivalent to

[[:paragraph {:content &quot;This is a paragraph&quot;
              :tag &quot;my-paragraph&quot;}]]</div></div><div class="paragraph"><p>Multiple attributes can be stacked to modify an element:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">[[{:numbered false}]]
[[{:lang &quot;shell&quot;}]]
(comment
  &gt; lein repl)</div></div><div class="paragraph"><p>produces the following shell code:</p></div><div class="code"><div hljs="hljs" language="shell" no-escape="no-escape">&gt; lein repl</div></div></section></section><section class="section" id="sectioning-elements"><h3 class="section">3.2  &nbsp;&nbsp; Sectioning Elements</h3><div class="paragraph"><p>Sectioning elements are taken from latex and allow the document to be organised into logical sections. From highest to lowest order of priority, they are: <code>:chapter</code>, <code>section</code>, <code>subsection</code> and <code>:subsubsection</code>, giving four levels of organisation.</p><p>The numbering for elements are generated in sequencial order: <code>&#40;1, 2, 3 ... etc&#41;</code> and a tag can be generated from the title or specified for creating links within the document. <code>:chapter</code>, <code>section</code> and <code>subsection</code> elements are list in the table of contents using tags.</p><p>For example, I wish to write a chapter about animals and have organised content into categories shown below.</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">Animals
- Mammals
- Birds
*- Can Fly
**- Eagle
**- Hummingbird
*- Flightless
**- Penguin</div></div><div class="paragraph"><p>It is very straight forward to turn this into sectioning elements which will then generate the sectioning numbers for different categories</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">[[:chapter {:title &quot;Animals&quot;}]]
[[:section {:title &quot;Mammals&quot;}]]
[[:section {:title &quot;Birds&quot;}]]
[[:subsection {:title &quot;Can Fly&quot;}]]
[[:subsubsection {:title &quot;Eagle&quot;}]]
[[:subsubsection {:title &quot;Hummingbird&quot;}]]
[[:subsection {:title &quot;Flightless&quot;}]]
[[:subsubsection {:title &quot;Penguin&quot;}]]</div></div><div class="paragraph"><p>The sections will be automatically numbered as show below:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">*1 Animals                ;; animals
*1.1 Mammals              ;; mammals
*1.2 Birds                ;; birds
  *1.2.1 Can Fly          ;; can-fly
    *1.2.1.1 Eagle        ;; eagle
    *1.2.1.2 Hummingbird  ;; hummingbird
  *1.2.2 Flightless       ;; flightless
    *1.2.2.1 Penguin      ;; penguin</div></div></section><section class="section" id="content-elements"><h3 class="section">3.3  &nbsp;&nbsp; Content Elements</h3><div class="paragraph"><p>Content elements include <code>:paragraph</code>, <code>:image</code>, and <code>file</code> elements.</p></div><section class="subsection" id="paragraph"><h4 class="subsection">3.3.1  &nbsp;&nbsp; :paragraph</h4><div class="paragraph"><p>Paragraph elements should make up the bulk of the documentation. They can be written as an element or in the usual case, as a string. The string is markdown with templating - so that chapter, section, code and image numbers can be referred to by their tags.</p></div><div class="code"><h5>e.3.2  &nbsp;-&nbsp; Paragraph Element</h5><div hljs="hljs" language="clojure" no-escape="no-escape">[[:paragraph {:content &quot;Here is some content&quot;}]]</div></div><div class="code"><h5>e.3.3  &nbsp;-&nbsp; Paragraph String</h5><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;Here is some content&quot;</div></div><div class="code"><h5>e.3.4  &nbsp;-&nbsp; Markdown String</h5><div hljs="hljs" language="clojure" no-escape="no-escape">[[:chapter {:title &quot;Chapter Heading&quot; :tag &quot;ch-heading&quot;}]]

&quot;
# Heading One
Here is some text.
Here is a tag reference to Chapter Heading - {{ch-heading}}

- Here is a bullet point
- Here is another one&quot;</div></div></section><section class="subsection" id="image"><h4 class="subsection">3.3.2  &nbsp;&nbsp; :image</h4><div class="paragraph"><p>The <code>:image</code> element embeds an image as a figure within the document. It is numbered and can be tagged for easy reference. The code example produces the image seen in Figure 2:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">[[:image {:tag &quot;clojure-logo&quot; :title &quot;Clojure Logo (source clojure.org)&quot;
          :src &quot;http://clojure.org/space/showimage/clojure-icon.gif&quot;}]]</div></div><div class="figure"><a name="clojure-logo"></a><div class="img"><img src="http://clojure.org/space/showimage/clojure-icon.gif" /></div><h4><i>fig.2  &nbsp;-&nbsp; Clojure Logo (source clojure.org)</i></h4></div></section><section class="subsection" id="file"><h4 class="subsection">3.3.3  &nbsp;&nbsp; :file</h4><div class="paragraph"><p>The <code>:file</code> element allows inclusion of other files into the document. It is useful for breaking up a document into managable chunks. A file element require that the <code>:src</code> attribute be specified. A high-level view of a document can thus be achieved, making the source more readable. This is similar to the <code>include</code> element in latex.</p></div><div class="code"><a name="file-element"></a><h5>e.3.5  &nbsp;-&nbsp; :file tag example</h5><div hljs="hljs" language="clojure" no-escape="no-escape">[[:file {:src &quot;test/docs/first_section.clj&quot;}]]
[[:file {:src &quot;test/docs/second_section.clj&quot;}]]
[[:file {:src &quot;test/docs/third_section.clj&quot;}]]</div></div></section></section><section class="section" id="code-elements"><h3 class="section">3.4  &nbsp;&nbsp; Code Elements</h3><div class="paragraph"><p>Code displayed in documentation are of a few types:</p><ol><li>Code that needs to be run (normal clojure code)</li><li>Code that needs verification taking input and showing output. (midje fact)</li><li>Code that should not be run (namespace declaration examples)</li><li>Code that is part of the library's tests or source definition</li><li>Code in other languages</li></ol><p>The different types of code can be defined so that code examples render properly using a variety of methods</p></div><section class="subsection" id="normal-s-expressions"><h4 class="subsection">3.4.1  &nbsp;&nbsp; normal s-expressions</h4><div class="paragraph"><p>Normal s-expressions are rendered as is. Attributes can be added for grouping purposes. The source code shown below</p></div><div class="code"><a name="c-add-src"></a><h5>e.3.6  &nbsp;-&nbsp; seperating code blocks through attributes</h5><div hljs="hljs" language="clojure" no-escape="no-escape">[[{:title &quot;add-n definition&quot; :tag &quot;c-add-1&quot;}]]
(defn add-n [n]
  (fn [x] (+ x n)))

[[{:title &quot;add-4 and add-5 definitions&quot; :tag &quot;c-add-2&quot;}]]
(def add-4 (add-n 4))
(def add-5 (add-n 5))</div></div><div class="paragraph"><p>renders the following outputs:</p></div><div class="code"><a name="c-add-1"></a><h5>e.3.7  &nbsp;-&nbsp; add-n definition</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(defn add-n [n]
  (fn [x] (+ x n)))</div></div><div class="code"><a name="c-add-2"></a><h5>e.3.8  &nbsp;-&nbsp; add-4 and add-5 definitions</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(def add-4 (add-n 4))
(def add-5 (add-n 5))</div></div></section><section class="subsection" id="test-forms"><h4 class="subsection">3.4.2  &nbsp;&nbsp; test forms</h4><div class="paragraph"><p>Documentation examples put in <code>facts</code> forms allows the code to be verified for correctness using <code>lein midje</code>. Document element notation still be rendered except before and after the midje arrows (<strong>=></strong>). Consecutive code within a fact form will stacked as one common code block.</p></div><div class="paragraph"><p>The source form:</p></div><div class="code"><a name="c-facts-src"></a><h5>e.3.9  &nbsp;-&nbsp; Facts Form Source</h5><div hljs="hljs" language="clojure" no-escape="no-escape">[[{:tag &quot;facts-form-output&quot; :title &quot;Facts Form Output&quot;}]]
(facts
  [[{:title &quot;Definining an atom&quot; :tag &quot;c-facts-1&quot;}]]
  (def a (atom 1))
  (deref a) =&gt; 1

  [[{:title &quot;Updating the atom&quot; :tag &quot;c-facts-2&quot;}]]
  (swap! a inc)
  (deref a) =&gt; 2)</div></div><div class="paragraph"><p>Renders the following output:</p></div><div class="code"><a name="c-facts-1"></a><h5>e.3.10  &nbsp;-&nbsp; Definining an atom</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(def a (atom 1))
(deref a) =&gt; 1</div></div><div class="code"><a name="c-factss-2"></a><h5>e.3.11  &nbsp;-&nbsp; Updating the atom</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(swap! a inc)
(deref a) =&gt; 2</div></div></section><section class="subsection" id="fact-form"><h4 class="subsection">3.4.3  &nbsp;&nbsp; fact form</h4><div class="paragraph"><p>For an entire block to be embedded in code, use the <code>fact</code> form. The source form:</p></div><div class="code"><a name="c-fact-src"></a><h5>e.3.12  &nbsp;-&nbsp; Fact Form Source</h5><div hljs="hljs" language="clojure" no-escape="no-escape">[[{:tag &quot;fact-form-output&quot; :title &quot;Fact Form Output&quot;}]]
(fact
  (def a (atom 1))
  (deref a) =&gt; 1

  (swap! a inc 1)
  (deref a) =&gt; 2)</div></div><div class="paragraph"><p>Renders the following output:</p></div><div class="code"><h5>e.3.13  &nbsp;-&nbsp; Fact Form Output</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(def a (atom 1))
(deref a) =&gt; 1

(swap! a inc)
(deref a) =&gt; 2</div></div></section><section class="subsection" id="comments"><h4 class="subsection">3.4.4  &nbsp;&nbsp; comments</h4><div class="paragraph"><p>Comments are clojure's built-in method of displaying non-running code and so this mechanisim is used in clojure for displaying code that should not be run, but still requires display. Code can still output without interferring with code or tests.</p></div><div class="code"><a name="c-com-src"></a><h5>e.3.14  &nbsp;-&nbsp; Switching to a new namespace</h5><div hljs="hljs" language="clojure" no-escape="no-escape">[[{:title &quot;Switching to a new namespace&quot; :tag &quot;c-com-1&quot;}]]
(comment
  (in-ns 'hello.world)
  (use 'clojure.string)
  (split &quot;Hello World&quot; #&quot;&#92;s&quot;) ;=&gt; [&quot;Hello&quot; &quot;World&quot;]
  )</div></div><div class="code"><a name="c-com-1"></a><h5>e.3.15  &nbsp;-&nbsp; Switching to a new namespace</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(in-ns 'hello.world)
(use 'clojure.string)
(split &quot;Hello World&quot; #&quot;&#92;s&quot;) ;=&gt; [&quot;Hello&quot; &quot;World&quot;]</div></div></section><section class="subsection" id="reference"><h4 class="subsection">3.4.5  &nbsp;&nbsp; reference</h4><div class="paragraph"><p>Sometimes we wish to refer to source/test code that is already in our library, we can do this using the <code>:reference</code> directive:</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">[[:reference {:refer hydrox.core/dive}]]</div></div><div class="code"><a name="source-hydrox-core--dive"></a><h5>e.3.16  &nbsp;-&nbsp; source of <i>hydrox.core/dive</i></h5><div hljs="hljs" language="clojure" no-escape="no-escape">(defn dive
  ([] (dive &quot;project.clj&quot;))
  ([path] (dive path {}))
  ([path opts]
   (-&gt;&gt; (io/file path)
        (util/read-project)
        (merge opts)
        (regulator/regulator)
        (component/start))))</div></div><div class="paragraph"><p>We can refer to tests as well by changing the <code>:mode</code> to <code>:docs</code> (by default it is <code>:source</code>):</p></div><div class="code"><div hljs="hljs" language="clojure" no-escape="no-escape">[[:reference {:refer hydrox.meta.util/append-node :mode :docs}]]</div></div><div class="code"><a name="docs-hydrox-meta-util--append-node"></a><h5>e.3.17  &nbsp;-&nbsp; docs of <i>hydrox.meta.util/append-node</i></h5><div hljs="hljs" language="clojure" no-escape="no-escape">&quot;Adds node as well as whitespace and newline on right&quot;

(-&gt; (z/of-string &quot;(+)&quot;)
    (z/down)
    (append-node 2)
    (append-node 1)
    (z/-&gt;root-string))
=&gt; &quot;(+&#92;n  1&#92;n  2)&quot;</div></div></section><section class="subsection" id="code"><h4 class="subsection">3.4.6  &nbsp;&nbsp; code</h4><div class="paragraph"><p>The most generic way of displaying code is with the <code>:code</code> tag. It is useful when code in other languages are required to be in the documentation.</p></div><section class="subsubsection" id="python-example"><h4 class="subsubsection">3.4.6.1  &nbsp;&nbsp; Python Example</h4><div class="paragraph"><p>The source and outputs are listed below:</p></div><div class="code"><a name="c-py-src"></a><h5>e.3.18  &nbsp;-&nbsp; Python for Loop Source</h5><div hljs="hljs" language="clojure" no-escape="no-escape">[[:code {:lang &quot;python&quot; :title &quot;Python for Loop&quot; :tag &quot;c-py-1&quot;}
&quot;
myList = [1,2,3,4]
for index in range(len(myList)):
  myList[index] += 1
print myList&quot;]]</div></div><div class="code"><a name="c-py-1"></a><h5>e.3.19  &nbsp;-&nbsp; Python for Loop</h5><div hljs="hljs" language="python" no-escape="no-escape">
myList = [1,2,3,4]
for index in range(len(myList)):
  myList[index] += 1
print myList</div></div></section><section class="subsubsection" id="ruby-example"><h4 class="subsubsection">3.4.6.2  &nbsp;&nbsp; Ruby Example</h4><div class="paragraph"><p>The source and outputs are listed below:</p></div><div class="code"><a name="c-rb-src"></a><h5>e.3.20  &nbsp;-&nbsp; Ruby for Loop Source</h5><div hljs="hljs" language="clojure" no-escape="no-escape">[[:code {:lang &quot;ruby&quot; :title &quot;Ruby for Loop&quot; :tag &quot;c-rb-2&quot;}
&quot;
array.each_with_index do |element,index|
  element.do_stuff(index)
end&quot;]]</div></div><div class="code"><a name="c-rb-2"></a><h5>e.3.21  &nbsp;-&nbsp; Ruby for Loop</h5><div hljs="hljs" language="ruby" no-escape="no-escape">
array.each_with_index do |element,index|
  element.do_stuff(index)
end</div></div></section></section></section></section><section class="chapter" id="a-bugs-life"><h2 class="chapter">4  &nbsp;&nbsp; A Bug's Life</h2><section class="section" id="version-one"><h3 class="section">4.1  &nbsp;&nbsp; Version One</h3><div class="paragraph"><p>A new clojure project is created.</p></div><div class="code"><div hljs="hljs" language="bash" no-escape="no-escape">&gt; lein new fami
&gt; cd fami
&gt; lein repl</div></div><div class="paragraph"><p>A very useful function <code>add-5</code> has been defined:</p></div><div class="code"><a name="add-5-fn"></a><h5>e.4.1  &nbsp;-&nbsp; src/fami/operations.clj</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(ns fami.operations)

(defn add-5
  &quot;add-5 is a function that takes any number of arguments
   and adds 5 to the sum&quot;
  [&amp; ns]
  (apply + 5 ns))</div></div><div class="paragraph"><p>And the corresponding tests specified:</p></div><div class="code"><a name="add-5-tests"></a><h5>e.4.2  &nbsp;-&nbsp; src/fami/test-operations.clj</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(ns fami.test-operations
  (:require [fami.operations :refer :all]
            [midje.sweet :refer :all]))

(fact &quot;add-5 should increment any list of numbers by 5&quot;
  (add-5 5)  =&gt; 10
  (add-5 1 2 3 4) =&gt; 15)</div></div><div class="paragraph"><p>There are additional entries for the operation in the readme as well as also being scattered around in various other documents.</p></div><div class="code"><a name="add-5-readme"></a><h5>e.4.3  &nbsp;-&nbsp; readme.md, operations.md</h5><div hljs="hljs" language="clojure" no-escape="no-escape">...

Here are some of the use cases for add-5

(add-5 5)    ;; =&gt; 10
(add-5 1 2 3 4)   ;; =&gt; 15
  
...</div></div><div class="paragraph"><p>This version of this library has been released as <strong>version 1.0</strong></p></div></section><section class="section" id="version-two"><h3 class="section">4.2  &nbsp;&nbsp; Version Two</h3><div class="paragraph"><p>The library is super successful with many users. The code undergoes refactoring and it is decided that the original <code>add-5</code> is too powerful and so it must be muted to only accept one argument. An additional function <code>add-5-multi</code> is used to make explicit that the function is taking multiple arguments.</p></div><div class="code"><a name="add-5-v2"></a><h5>e.4.4  &nbsp;-&nbsp; src/fami/operations.clj - v2</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(ns fami.operations)

(defn add-5 [n]   ;; The muted version
  &quot;add-5 is a function that takes a number and adds 5 to it&quot;
  (+ n 5))

(defn add-5-multi
  &quot;add-5-multi is a function that takes any number of arguments
   and adds 5 to the sum&quot;
  [&amp; ns]
  (apply + 5 ns))</div></div><div class="paragraph"><p>The tests throw an exception but are quickly fixed:</p></div><div class="code"><a name="add-5-v2-tests"></a><h5>e.4.5  &nbsp;-&nbsp; src/fami/test-operations.clj</h5><div hljs="hljs" language="clojure" no-escape="no-escape">(ns fami.test-operations
 (:require [fami.operations :refer :all]
           [midje.sweet :refer :all]))

 (fact &quot;add-5 should increment only one input by 5&quot;
 (add-5 5) =&gt; 10
 (add-5 1 2) =&gt; (throws clojure.lang.ArityException))

 (fact &quot;add-5-multi should increment any list of numbers by 5&quot;
 (add-5-multi 1 2 3 4) =&gt; 15)</div></div><div class="paragraph"><p>This version of this library has been released as <strong>version 2.0</strong></p></div></section><section class="section" id="the-bug-surfaces"><h3 class="section">4.3  &nbsp;&nbsp; The Bug Surfaces</h3><div class="paragraph"><p>Although the tests are correct, the documentation is not. Anyone using this library can potentially have the <code>clojure.lang.ArityException</code> bug if they carefully followed instructions in the documentation.</p><p>This is a trival example of a much greater problem. When a project begins to evolve and codebase begins to change, the documentation then becomes incorrect. Although source and test code can be isolated through testing, fixing documentation is a miserable and futile exercise of cut and paste. With no real tool to check whether code is still valid, the documentation become less and less correct until all the examples have to be rechecked and the documention rewritten.</p><p><strong>Then the codebase changes again ...</strong></p><p>Once the library has been release to the world and people have already started using it, there is no taking it back. Bugs propagate through miscommunication. Miscommunication with machines can usually be contained and fixed. Miscommunication with people becomes potentially more difficult to contain.</p><p>This simple scenario highlights the problem that developers have when updating documentation. When we cannot <code>prove</code> that our documentation is correct, then the cost of fixing out of date documentation becomes bigger and bigger as time progresses. With <code>hydrox</code> this process just became much more cost effective.</p></div></section></section>
    </div>
</div><!--end of .container-->

</body>

<script>
  $('#nav').affix({
    offset: {
        top: $('#nav').offset().top,
        bottom: $('footer').outerHeight(true) + $('.application').outerHeight(true) + 40
    }});
</script>


<script>
  if (document.location.search.match(/type=embed/gi)) {
    window.parent.postMessage("resize", "*");
  }
</script>
</body>
</html>
